/**
* LCDWolf3D
* jaburns
*/

#include <stdbool.h>
#include <math.h>
#include "trigonometry.h"

#include <stm32f10x.h>
#include <gfx.h>
#if USE_FSMC
 #include <fsmcdrv.h>
#else
 #include <spi.h>
#endif
//#include <memHelper.h>

//#include "gpuTiles.h"
#include "raycast.h"

// ---------------------------------- //
float px =  70.0f;
float py = 170.0f;
float pa = -PI_NUM / 2.0f;
// ---------------------------------- //

uint16_t sliceDMABuf[LCD_HEIGHT];

uint8_t renderStep = RENDER_STEP_SIZE;


// in texture mode == 1 drawed textures 16x16px
// in texture mode == 2 drawed textures 32x32px
//uint8_t textureMode = 1;
// ---------------------------------- //


// -------------------------------------------------------------------- //
const uint8_t tex_wood[] = {
   0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0x08, 0x00, 0xf0, 0x7f, 0x00, 0xf0, 0xff, 0xf1, 0x08, 0xfc, 0xff, 0x07,
   0x00, 0xff, 0x3f, 0xf0, 0xf8, 0xff, 0x03, 0x00, 0xfe, 0xff, 0x07, 0xfe,
   0x08, 0x00, 0x00, 0xff, 0xff, 0x7f, 0xc0, 0xff, 0xf8, 0xff, 0xff, 0xff,
   0x7f, 0x00, 0xf8, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0xff,
   0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x83, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8,
   0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0x18, 0x80, 0x3f, 0x00, 0xff, 0x07, 0xfc, 0xff, 0x38, 0x00, 0x7f, 0x00,
   0xfc, 0x0f, 0xc0, 0xff, 0x78, 0x00, 0xfe, 0x00, 0xf8, 0x1f, 0x00, 0xff,
   0x38, 0x00, 0x7f, 0x00, 0xfe, 0x07, 0x80, 0xff, 0x18, 0xc0, 0x3f, 0xc0,
   0xff, 0x01, 0xf8, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0xfc, 0x1f,
   0xc0, 0xff, 0x01, 0xf0, 0xf8, 0x3f, 0xe0, 0xff, 0x00, 0xfe, 0x07, 0xc0,
   0x08, 0xfe, 0x81, 0xff, 0x03, 0xf0, 0x0f, 0x80, 0x08, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff, 0xff, 0xff,
   0xff, 0xff, 0x7f, 0x80, 0x08, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0x8f,
   0xf8, 0xff, 0xff, 0xff, 0x1f, 0x00, 0xfe, 0xbf, 0x08, 0x00, 0x00, 0xff,
   0xff, 0x1f, 0xc0, 0xff, 0xf8, 0xff, 0xff, 0x01, 0xfc, 0xff, 0x03, 0xfc,
   0x08, 0xfe, 0xff, 0x3f, 0x00, 0xff, 0x3f, 0xf0, 0x08, 0x00, 0xff, 0xff,
   0x07, 0xf0, 0xff, 0xe1, 0xf8, 0x00, 0xc0, 0xff, 0x1f, 0xc0, 0xff, 0xc3,
   0xf8, 0x03, 0x00, 0xff, 0x3f, 0x80, 0xff, 0xe1, 0xf8, 0x07, 0x00, 0xff,
   0x1f, 0xc0, 0xff, 0xf0, 0xf8, 0x01, 0xe0, 0xff, 0x07, 0xf0, 0x3f, 0xfc,
   0x18, 0x00, 0xfe, 0xff, 0x01, 0xfe, 0x07, 0xff, 0x08, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xe8, 0x8f, 0xff, 0xf9, 0xff, 0xf3, 0xff, 0x87, 0x08, 0x3f, 0xf8, 0x9f,
   0xff, 0x0f, 0xf8, 0xff, 0x08, 0xfe, 0xc1, 0x7f, 0xfc, 0x3f, 0xc0, 0xff,
   0x08, 0x7f, 0xc0, 0xff, 0xfb, 0xff, 0x80, 0xff, 0xc8, 0x3f, 0xf0, 0xff,
   0xfc, 0x3f, 0xf0, 0xff, 0xf8, 0x0f, 0xfc, 0x9f, 0xff, 0x0f, 0xfe, 0xff,
   0xf8, 0xc0, 0xff, 0xf1, 0xff, 0xe1, 0xff, 0x9f
};


const uint8_t tex_bricks[] = {
   0x00, 0xf0, 0x0f, 0x00, 0xff, 0x00, 0xf0, 0x1f, 0xbc, 0xf3, 0xcf, 0x3a,
   0xff, 0xfc, 0xf3, 0x0e, 0xfc, 0xf1, 0xcb, 0x2f, 0xff, 0x7c, 0xf1, 0x1f,
   0xfc, 0xf3, 0xcf, 0x3f, 0x7f, 0xfc, 0xf3, 0x0f, 0xfc, 0xf3, 0xc7, 0x3f,
   0xff, 0xfc, 0xf1, 0x1d, 0xfc, 0xf2, 0xcf, 0x2f, 0xff, 0xfc, 0xf3, 0x0f,
   0xfc, 0xf3, 0xcf, 0x3f, 0xff, 0xfc, 0xf1, 0x1f, 0xfc, 0xf1, 0xcf, 0x1f,
   0x7f, 0xfc, 0xf3, 0x0f, 0xfc, 0x03, 0xc0, 0x3f, 0xff, 0xfc, 0xf3, 0x1f,
   0xfc, 0x02, 0xc0, 0x1f, 0xff, 0xfc, 0xf1, 0x1f, 0xfc, 0x03, 0xc0, 0x3f,
   0xff, 0xfc, 0xf3, 0x16, 0xfc, 0xf1, 0xcf, 0x1f, 0xff, 0xfc, 0xf1, 0x0f,
   0xfc, 0x73, 0xc5, 0x3f, 0xff, 0xfc, 0xf3, 0x1f, 0xfc, 0xf1, 0xcf, 0x1f,
   0xff, 0xfc, 0xf2, 0x1f, 0xfc, 0xf2, 0xcf, 0x3f, 0xff, 0xfc, 0x03, 0x00,
   0xfc, 0xf3, 0xcf, 0x1f, 0xff, 0xbc, 0x03, 0x00, 0xfc, 0xf3, 0xcb, 0x3f,
   0x7f, 0xfc, 0x01, 0x00, 0xfc, 0xf2, 0xcf, 0x2f, 0xff, 0xfc, 0xb3, 0x1e,
   0xfc, 0xf3, 0xc7, 0x3f, 0xff, 0xfc, 0xf1, 0x17, 0xfc, 0xf1, 0xcf, 0x3f,
   0x7f, 0xfc, 0xf3, 0x1f, 0xfc, 0xf3, 0xc7, 0x3f, 0xff, 0xfc, 0xf1, 0x1f,
   0xfc, 0xf1, 0xcf, 0x2f, 0x00, 0xfc, 0xf3, 0x1f, 0xfc, 0xf3, 0xcb, 0x3f,
   0x00, 0xfc, 0x71, 0x1d, 0xfc, 0xf3, 0xcf, 0x1f, 0x00, 0xfc, 0xf3, 0x0f,
   0x00, 0xf0, 0xcf, 0x3f, 0xbf, 0xdc, 0xf1, 0x1f, 0x00, 0xf0, 0xc7, 0x1f,
   0x7f, 0xfc, 0xf3, 0x1f, 0x00, 0xf0, 0xcf, 0x3f, 0xff, 0x7c, 0xf3, 0x0e,
   0xbc, 0xf3, 0xcb, 0x1f, 0x7f, 0xfc, 0xf3, 0x1f, 0xfc, 0xf1, 0xcf, 0x3f,
   0xff, 0xfc, 0xf3, 0x0f, 0xfc, 0xf1, 0xc7, 0x3f, 0xff, 0x00, 0xf0, 0x1f,
   0xfc, 0xf3, 0xcf, 0x1f, 0x7f, 0x00, 0xf0, 0x1f, 0xfc, 0xf2, 0xcf, 0x3f,
   0xff, 0x00, 0xf0, 0x1f, 0xfc, 0xf3, 0xcb, 0x3f, 0x7f, 0xfc, 0xf3, 0x1d,
   0xfc, 0xf1, 0x0f, 0x00, 0xff, 0xfc, 0xf1, 0x0f, 0xfc, 0xf3, 0x0a, 0x00,
   0xdf, 0xfc, 0xf2, 0x1f, 0xfc, 0xf1, 0x0f, 0x00, 0x7f, 0xfc, 0xb3, 0x1f,
   0xfc, 0xf3, 0xcf, 0x3f, 0xff, 0xfc, 0xf3, 0x1f, 0xfc, 0xf2, 0xc7, 0x1f,
   0x7f, 0xfc, 0xf1, 0x0b, 0xfc, 0xf3, 0xcf, 0x2f, 0xff, 0xfc, 0xf3, 0x1f,
   0xfc, 0xf1, 0xcf, 0x3f, 0x7f, 0xfc, 0xf1, 0x1e, 0xfc, 0xf3, 0xc7, 0x3f,
   0xff, 0xfc, 0xf3, 0x0f, 0xfc, 0xf3, 0xcf, 0x1f, 0xff, 0xfc, 0xf3, 0x1f,
   0xfc, 0xf1, 0xcf, 0x3f, 0xff, 0xfc, 0xf0, 0x1f, 0xfc, 0xf3, 0xcf, 0x1f,
   0x7f, 0xfc, 0x03, 0x00, 0xfc, 0xf1, 0xcf, 0x3f, 0xff, 0x7c, 0x03, 0x00,
   0xfc, 0x03, 0xc0, 0x1f, 0x7f, 0xfc, 0x01, 0x00, 0xfc, 0x03, 0xc0, 0x3f,
   0xff, 0xfc, 0xf3, 0x1f, 0xfc, 0x03, 0xc0, 0x1f, 0xff, 0xfc, 0xf3, 0x1d,
   0x00, 0xf0, 0xcf, 0x3f, 0x7f, 0xfc, 0xf1, 0x1f, 0x00, 0xf0, 0xc7, 0x1f,
   0xff, 0xfc, 0xf3, 0x0e, 0x00, 0xf0, 0xcf, 0x3f, 0x00, 0xfc, 0xf3, 0x1f,
   0xfc, 0xf3, 0xcf, 0x1f, 0x00, 0xfc, 0xf1, 0x1f, 0x5c, 0xf1, 0xc7, 0x3f,
   0x00, 0xfc, 0x73, 0x0f, 0xfc, 0xf3, 0xcf, 0x2f, 0xff, 0xfc, 0xf3, 0x1f,
   0xfc, 0xf1, 0xc7, 0x3f, 0x57, 0xfc, 0xf1, 0x0f, 0xfc, 0xf3, 0xcf, 0x3b,
   0xff, 0xfc, 0xf3, 0x1f, 0xfc, 0xf1, 0xc7, 0x1f, 0xff, 0xfc, 0xf3, 0x17,
   0xfc, 0xf3, 0xcf, 0x3f, 0x7f, 0xfc, 0xf1, 0x1f, 0xfc, 0xf1, 0xc7, 0x17,
   0xff, 0xfc, 0xf3, 0x0e, 0xfc, 0xf3, 0xcb, 0x3f, 0xff, 0xfc, 0xf1, 0x1f,
   0xfc, 0xf1, 0xcf, 0x1f, 0x7f, 0xfc, 0xf3, 0x1f, 0xfc, 0xf3, 0xcf, 0x3f,
   0xff, 0xfc, 0xf3, 0x1f, 0xfc, 0xf3, 0xc7, 0x3f, 0xff, 0xfc, 0xf3, 0x0f,
   0x00, 0xf0, 0x0f, 0x00, 0x7f, 0x00, 0xf0, 0x1b
};

const uint8_t tex_bird[] = {
   0x00, 0xf0, 0x0f, 0x00, 0xff, 0x00, 0xf0, 0x1f, 0xe4, 0xf3, 0xcf, 0x3f,
   0xff, 0xfc, 0xf3, 0x1f, 0xcc, 0xf3, 0xcf, 0x3f, 0xff, 0xfc, 0xf3, 0x1f,
   0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x1f, 0x8c, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x80, 0x1f, 0x0c, 0xf7, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x1f,
   0x8c, 0xc3, 0xff, 0xff, 0xff, 0xff, 0x07, 0x1f, 0x8c, 0x3e, 0xff, 0x03,
   0xff, 0xff, 0x0f, 0x1f, 0x8c, 0xfc, 0x0c, 0x02, 0xc6, 0xff, 0x1f, 0x1e,
   0x0c, 0xfe, 0x0f, 0x06, 0x06, 0xff, 0x1f, 0x1e, 0x8c, 0x3e, 0x0e, 0x06,
   0x02, 0xfe, 0x3f, 0x1e, 0x8c, 0x1f, 0x1c, 0x04, 0x02, 0xfe, 0x3f, 0x1c,
   0x8c, 0x1f, 0x18, 0x04, 0x02, 0xfe, 0x3f, 0x1c, 0x8c, 0x3f, 0x18, 0x04,
   0x00, 0x66, 0x3e, 0x1c, 0x8c, 0x71, 0x10, 0x04, 0x00, 0x06, 0x3e, 0x00,
   0x8c, 0xe1, 0x00, 0x04, 0x00, 0x04, 0x7f, 0x00, 0x8c, 0xc3, 0x20, 0x04,
   0x00, 0x80, 0x7f, 0x00, 0x8c, 0x87, 0x01, 0x04, 0x00, 0x08, 0x7c, 0x18,
   0x8c, 0x87, 0x01, 0x04, 0x00, 0x08, 0xf8, 0x10, 0x8c, 0x0f, 0x01, 0x00,
   0x00, 0x0c, 0xff, 0x10, 0x8c, 0x0f, 0x00, 0x00, 0x00, 0x8e, 0xf3, 0x10,
   0x8c, 0x1f, 0x00, 0x00, 0x00, 0x87, 0xf1, 0x11, 0x8c, 0x1f, 0x00, 0x00,
   0x40, 0x04, 0xe1, 0x01, 0x8c, 0x1f, 0x00, 0x00, 0x20, 0x00, 0xe0, 0x01,
   0x80, 0x3f, 0x04, 0x00, 0x10, 0xe0, 0xe0, 0x03, 0x80, 0x2f, 0x02, 0x00,
   0x00, 0x60, 0xe0, 0x03, 0x80, 0x67, 0x02, 0x00, 0x00, 0x60, 0xe0, 0x03,
   0x8c, 0xe7, 0x0f, 0x00, 0x00, 0x20, 0xf0, 0x03, 0x8c, 0xc7, 0x09, 0xff,
   0x00, 0x10, 0x88, 0x07, 0x8c, 0x07, 0x00, 0xff, 0x00, 0x00, 0x00, 0x07,
   0x8c, 0x07, 0x00, 0xff, 0x01, 0x00, 0x00, 0x06, 0x8c, 0x07, 0x00, 0xff,
   0x01, 0x00, 0x00, 0x0c, 0x8c, 0x07, 0x00, 0xff, 0x01, 0x00, 0x00, 0x0c,
   0x8c, 0x07, 0x00, 0xff, 0x01, 0x00, 0x00, 0x06, 0x8c, 0x07, 0x00, 0xff,
   0x00, 0x00, 0x00, 0x07, 0x8c, 0xc7, 0x09, 0xff, 0x00, 0x10, 0x88, 0x07,
   0x8c, 0xff, 0x0f, 0x00, 0x00, 0x20, 0xf0, 0x03, 0x8c, 0x7f, 0x02, 0x00,
   0x00, 0x60, 0xe0, 0x03, 0x8c, 0x3f, 0x02, 0x00, 0x00, 0x60, 0xe0, 0x03,
   0x8c, 0x3f, 0x04, 0x00, 0x10, 0xe0, 0xe0, 0x03, 0x8c, 0x1f, 0x00, 0x00,
   0x20, 0x00, 0xe0, 0x01, 0x8c, 0x1f, 0x00, 0x00, 0x40, 0x04, 0xe1, 0x01,
   0x8c, 0x1f, 0x00, 0x00, 0x00, 0x87, 0xf1, 0x01, 0x8c, 0x0f, 0x00, 0x00,
   0x00, 0x8e, 0xf3, 0x00, 0x8c, 0x0f, 0x01, 0x00, 0x00, 0x0c, 0xff, 0x00,
   0x8c, 0x87, 0x21, 0x04, 0x00, 0x08, 0xf8, 0x00, 0x8c, 0x87, 0x21, 0x04,
   0x00, 0x08, 0x7c, 0x18, 0x8c, 0xc3, 0x20, 0x04, 0x00, 0x80, 0x7f, 0x18,
   0x80, 0xe1, 0x30, 0x04, 0x00, 0x04, 0x7f, 0x18, 0x80, 0x73, 0x30, 0x04,
   0x00, 0x06, 0x3e, 0x18, 0x80, 0x7f, 0x18, 0x04, 0x00, 0x66, 0x3e, 0x1c,
   0x8c, 0x1f, 0x18, 0x04, 0x02, 0xfe, 0x3f, 0x1c, 0x8c, 0x1f, 0x1c, 0x04,
   0x02, 0xfe, 0x3f, 0x1c, 0x8c, 0x3e, 0x0e, 0x06, 0x02, 0xfe, 0x1f, 0x1e,
   0x0c, 0xfc, 0x07, 0x06, 0x06, 0xff, 0x1f, 0x1e, 0x8c, 0xfe, 0x07, 0x02,
   0xc6, 0xff, 0x1f, 0x1e, 0x8c, 0xff, 0xff, 0x03, 0xff, 0xff, 0x0f, 0x1e,
   0x8c, 0xe7, 0xff, 0xff, 0xff, 0xff, 0x07, 0x1f, 0x8c, 0xf7, 0xff, 0xff,
   0xff, 0xff, 0x0f, 0x1f, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x1f,
   0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x1f, 0xcc, 0xf3, 0xcf, 0x3f,
   0xff, 0xfc, 0xf3, 0x1f, 0x84, 0xf3, 0xcf, 0x3f, 0xff, 0xfc, 0xf3, 0x1f,
   0x00, 0xf0, 0x0f, 0x00, 0xff, 0x00, 0xf0, 0x1f
};

const uint8_t tex_bricks2[] = {
   0xf8, 0x03, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x03, 0xff, 0x03,
   0x00, 0x00, 0x00, 0x00, 0xf8, 0x03, 0xff, 0x83, 0x01, 0x03, 0x00, 0x04,
   0xf8, 0x03, 0xff, 0x83, 0x1f, 0xff, 0x07, 0x1e, 0xf8, 0x03, 0xff, 0x81,
   0x1f, 0xff, 0x0f, 0x1e, 0xf8, 0x03, 0xff, 0x81, 0x1f, 0xff, 0x0f, 0x1e,
   0xf8, 0x03, 0xff, 0x81, 0x1f, 0xff, 0x0f, 0x1e, 0xf8, 0x07, 0xff, 0x81,
   0x1f, 0xff, 0x0f, 0x1e, 0xf8, 0x07, 0xff, 0xc1, 0x1f, 0xff, 0x0f, 0x1e,
   0xf8, 0x07, 0xff, 0xc1, 0x1f, 0xff, 0x0f, 0x1e, 0xfc, 0x07, 0xff, 0xc3,
   0x1f, 0xff, 0x0f, 0x1e, 0xfc, 0x07, 0xff, 0xc3, 0x1f, 0xff, 0x0f, 0x1e,
   0xfc, 0x07, 0xfe, 0xc1, 0x3f, 0xff, 0x0f, 0x1e, 0xfc, 0x07, 0x00, 0x00,
   0x00, 0xff, 0x0f, 0x1e, 0xfc, 0x0f, 0x00, 0x00, 0x00, 0xff, 0x0f, 0x1e,
   0xfc, 0x0f, 0xff, 0x01, 0x00, 0xff, 0x0f, 0x1e, 0xfc, 0x1f, 0xff, 0xff,
   0x07, 0xff, 0x0f, 0x1c, 0xfc, 0x1f, 0xff, 0xff, 0x0f, 0xff, 0x0f, 0x00,
   0xfc, 0x01, 0xff, 0xff, 0x1f, 0xff, 0x0f, 0x00, 0x00, 0x00, 0xe0, 0xff,
   0x1f, 0xfe, 0x0f, 0x0e, 0x00, 0x00, 0x80, 0xff, 0x1f, 0xfe, 0x0f, 0x0e,
   0x00, 0x08, 0x00, 0x00, 0x00, 0xfe, 0x0f, 0x06, 0x02, 0x38, 0x00, 0x00,
   0x00, 0xfe, 0x0f, 0x0f, 0x1e, 0xf8, 0x03, 0x00, 0x00, 0xfe, 0x0f, 0x0f,
   0xfe, 0xf8, 0xc3, 0x01, 0x00, 0xfe, 0x0f, 0x0f, 0xfe, 0xf8, 0xc7, 0xff,
   0x03, 0xfe, 0x0f, 0x0f, 0xfe, 0xf8, 0xc7, 0xff, 0x0f, 0xfe, 0x0f, 0x0f,
   0xfe, 0xf8, 0xc7, 0xff, 0x1f, 0xfe, 0x07, 0x00, 0xfe, 0xf8, 0xcf, 0xff,
   0x1f, 0xfe, 0x07, 0x00, 0xfe, 0xf8, 0xcf, 0xff, 0x1f, 0xfe, 0x07, 0x00,
   0xfe, 0xf0, 0xcf, 0xff, 0x1f, 0xfe, 0x07, 0x00, 0xfe, 0xf1, 0xdf, 0xff,
   0x1f, 0xfe, 0xc7, 0x00, 0xfe, 0xf0, 0xdf, 0xff, 0x1f, 0xfe, 0xc7, 0x01,
   0x7e, 0x00, 0x80, 0xff, 0x3f, 0xfe, 0xc7, 0x03, 0x1e, 0x00, 0x80, 0xff,
   0x3f, 0xfe, 0xc7, 0x03, 0x00, 0x00, 0x80, 0xff, 0x7f, 0xfe, 0xc7, 0x03,
   0x00, 0x00, 0x80, 0xff, 0x7f, 0xfe, 0xc7, 0x03, 0x06, 0x82, 0x82, 0xff,
   0x3f, 0x1c, 0xc0, 0x03, 0x7e, 0x3f, 0x87, 0xff, 0x0f, 0x00, 0xe0, 0x03,
   0xfe, 0xff, 0x0f, 0xff, 0x00, 0x00, 0xe0, 0x03, 0xfe, 0xff, 0x07, 0x00,
   0x00, 0x00, 0xe0, 0x03, 0xfe, 0xff, 0x0f, 0x00, 0x00, 0x00, 0xe0, 0x03,
   0xfe, 0xff, 0x07, 0x00, 0x00, 0x00, 0xe0, 0x03, 0xfe, 0xff, 0x87, 0x83,
   0x61, 0x62, 0xe0, 0x03, 0xfe, 0xff, 0x8f, 0xff, 0xff, 0xff, 0xe0, 0x03,
   0xfe, 0xff, 0x8f, 0xff, 0xff, 0xff, 0xe0, 0x03, 0xfe, 0xff, 0x8f, 0xff,
   0xff, 0xff, 0xe0, 0x03, 0xfe, 0xff, 0x8f, 0xff, 0xff, 0xff, 0xe0, 0x03,
   0xfe, 0xff, 0x8f, 0xff, 0xff, 0xff, 0xe0, 0x03, 0xfe, 0xff, 0x8f, 0xff,
   0xff, 0xff, 0xe0, 0x03, 0xfe, 0xff, 0x87, 0xff, 0xff, 0xff, 0xe1, 0x03,
   0xfe, 0xff, 0x80, 0xff, 0xff, 0x00, 0xf0, 0x03, 0xfe, 0x0f, 0x00, 0x00,
   0x00, 0x00, 0xf0, 0x03, 0x00, 0x00, 0x00, 0x40, 0x03, 0x00, 0xf0, 0x03,
   0x00, 0x00, 0x00, 0xe0, 0xff, 0x03, 0xf0, 0x03, 0x00, 0x00, 0x0f, 0xe0,
   0xff, 0x3f, 0xf0, 0x03, 0x78, 0x00, 0x7f, 0xe0, 0xff, 0x3f, 0xf8, 0x03,
   0x78, 0x00, 0xff, 0xe3, 0xff, 0x3f, 0xf8, 0x03, 0xf8, 0x01, 0xff, 0xe3,
   0xff, 0x7f, 0xf8, 0x03, 0xf8, 0x03, 0xff, 0xe3, 0xff, 0x7f, 0xf8, 0x03,
   0xf8, 0x07, 0xff, 0xe3, 0xff, 0xff, 0xf8, 0x03, 0xf8, 0x07, 0xff, 0xc3,
   0xff, 0xff, 0xf8, 0x07, 0xf8, 0x07, 0xff, 0xc3, 0xff, 0xff, 0xf8, 0x0f,
   0xf8, 0x07, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00
};


// all textures have size 64x64
const uint8_t *textures[] =
{
  0, // no texture
  tex_wood,
  tex_bricks,
  tex_bird,
  tex_bricks2
};

// ---------------------------------- //

// 24x24
const uint8_t level[] = {
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,2,2,3,2,2,3,2,2,3,2,2,4,4,4,4,4,4,4,4,4,4,4,1,
  1,2,0,0,0,0,0,0,0,0,0,2,4,0,0,0,0,0,0,0,0,0,4,1,
  1,3,0,0,0,0,0,0,0,0,0,3,4,0,0,0,0,0,0,0,0,0,4,1,
  1,2,0,0,0,3,2,2,2,0,0,2,4,0,0,4,0,4,0,4,0,0,4,1,
  1,2,0,0,0,2,2,0,0,0,0,2,4,0,0,0,0,0,0,0,0,0,4,1,
  1,3,0,0,0,3,3,0,0,0,0,3,4,0,0,4,0,0,0,4,0,0,4,1,
  1,2,2,0,2,2,2,0,0,0,0,2,4,0,0,0,0,4,4,4,0,0,4,1,
  1,0,2,3,2,0,2,2,0,2,2,2,4,4,4,4,4,0,0,0,4,4,4,1,
  1,0,0,0,0,0,0,4,0,4,4,4,4,4,4,4,0,0,0,0,0,4,4,1,
  1,0,0,0,0,0,0,4,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,1,
  1,0,0,0,0,0,0,4,0,0,0,0,0,0,4,0,0,0,3,0,0,0,4,1,
  1,0,0,0,0,0,0,4,0,4,4,4,0,0,0,0,0,0,0,0,0,0,4,1,
  1,0,0,0,0,0,0,4,3,4,4,4,4,4,4,4,0,0,0,0,0,4,4,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,4,4,4,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,0,0,0,1,
  1,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,
  1,4,0,4,0,0,0,0,4,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,
  1,4,0,0,0,0,3,0,4,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,
  1,4,0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,
  1,4,0,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
};

// -------------------------------------------------------------------- //


void castRay( float x, float y, float angle, uint16_t screenX, slice_t *result )
{
  float ox = x;        // origin coordinates
  float oy = y;
  
  float offsetAngle = ( (float)screenX * ( PI_1_3_NUM ) ) / LCD_WIDTH - ( PI_1_6_NUM );
  angle += offsetAngle;
  
  bool yAxisWall = false;
  
  float blockX = (float)( (uint16_t)( x / BLOCK_SIZE ) );    // The coordinate of the block we're sitting in
  float blockY = (float)( (uint16_t)( y / BLOCK_SIZE ) );
  
  float cosine = cos( angle );
  float sine   = sin( angle );
  
  if( sine   <  0.000001f && sine   >= 0.0f ) sine   =  0.000001f;
  if( sine   > -0.000001f && sine   <  0.0f ) sine   = -0.000001f;
  if( cosine <  0.000001f && cosine >= 0.0f ) cosine =  0.000001f;
  if( cosine > -0.000001f && cosine <  0.0f ) cosine = -0.000001f;
  
  float oneOverCosine = 1.0f / cosine;
  float oneOverSine   = 1.0f / sine;
  
  float xNext_x, xNext_y, xNext_l;
  float yNext_x, yNext_y, yNext_l;
  
  float stepX, stepY;
  stepX = cosine > 0 ? 1.0f : -1.0f;
  stepY = sine > 0 ? 1.0f : -1.0f;
  
  //perform DDA
  do
  {
    xNext_x = blockX * BLOCK_SIZE_F;
    if( cosine > 0 ) xNext_x += BLOCK_SIZE_F;
    xNext_x -= x;
    xNext_l = xNext_x * oneOverCosine;
    
    yNext_y = blockY * BLOCK_SIZE_F;
    if( sine > 0 ) yNext_y += BLOCK_SIZE_F;
    yNext_y -= y;
    yNext_l = yNext_y * oneOverSine;
    
    if( xNext_l < yNext_l )
    {
      yAxisWall = true;
      xNext_y = xNext_l * sine;
      blockX += stepX;
      x += xNext_x;
      y += xNext_y;
    }
    else
    {
      yAxisWall = false;
      yNext_x = yNext_l * cosine;
      blockY += stepY;
      x += yNext_x;
      y += yNext_y;
    }
    
    result->textureId =  level[ (uint16_t)( blockX + MAP_WIDTH * blockY ) ];
  }
  while( result->textureId == 0 );
  
  result->targetBlockX = (uint16_t)blockX;
  result->targetBlockY = (uint16_t)blockY;
  
  if( yAxisWall ) {
    result->textureOffset = (uint16_t)( (uint16_t)( y * TEXTURE_SIZE_OFF ) % TEXTURE_SIZE );
  } else {
    result->textureOffset = (uint16_t)( (uint16_t)( x * TEXTURE_SIZE_OFF ) % TEXTURE_SIZE );
  }
  
  float dx = x - ox;
  float dy = y - oy;
  float dd = sqrt( dx*dx + dy*dy ) * cos( offsetAngle );
  
  result->sliceHeight = (uint16_t)( VISPLANEDIST_TIMES_WALLHEIGHT / dd );
}

void drawSlice( uint16_t screenX, slice_t *slice )
{
  uint16_t offsetY   = ( slice->sliceHeight >  LCD_HEIGHT ) ? ( 0 ) : ( (LCD_HEIGHT/2) - ( slice->sliceHeight >> 1 ) );
  slice->overflowY = ( slice->sliceHeight <= LCD_HEIGHT ) ? ( 0 ) : ( ( slice->sliceHeight - LCD_HEIGHT ) >> 1 );
  
  uint16_t sliceYcount =0;
  
  for(; sliceYcount < slice->sliceHeight && sliceYcount < LCD_HEIGHT; sliceYcount++ ) {
    
    // "<< 6" is equal to "*TEXTURE_SIZE"
    if( GET_WALL_DOT( textures[ slice->textureId ], slice->textureOffset,
                     ( ( sliceYcount + slice->overflowY ) << 6 ) / slice->sliceHeight ) )
    //if( GET_WALL_DOT( textures[ slice->textureId ], slice->textureOffset,
                  // ( ( sliceYcount + slice->overflowY ) * TEXTURE_SIZE ) / slice->sliceHeight ) )
    {
      sliceDMABuf[sliceYcount] = COLOR_WHITE;
    } else {
      sliceDMABuf[sliceYcount] = COLOR_BLACK;
    }
  }
  
  setVAddrWindow(OFFSET_X+screenX, OFFSET_Y+offsetY, OFFSET_Y+offsetY+sliceYcount);
  sendData16_Fast_DMA1_SPI1(sliceDMABuf, sliceYcount);
}

bool shouldInterpolate( slice_t *sliceA, slice_t *sliceB )
{
  if( sliceA->textureId != sliceB->textureId ) return false;
  
  uint16_t xDiff = UNSIGNED_DIFF( sliceA->targetBlockX, sliceB->targetBlockX );
  uint16_t yDiff = UNSIGNED_DIFF( sliceA->targetBlockY, sliceB->targetBlockY );
  
  if( xDiff == 0 && yDiff <= 1 ) return true;
  if( xDiff <= 1 && yDiff == 0 ) return true;
  
  return false;
}

void render(void)
{
  // clear previous render frame
  fillRect(OFFSET_X+0, OFFSET_Y+0, LCD_WIDTH, LCD_HEIGHT, COLOR_BLACK);
  
  slice_t sliceA, sliceB;
  slice_t sliceX[ 3 ];
  
  castRay( px, py, pa, 0, &sliceA );
  
  for( uint16_t x = renderStep ; x < LCD_WIDTH ; x += renderStep )
  {
    castRay( px, py, pa, x, &sliceB );
    
    if( shouldInterpolate( &sliceA , &sliceB ) )
    {
      sliceX[1].textureId     = sliceA.textureId;
      sliceX[1].textureOffset = ( sliceA.textureOffset + sliceB.textureOffset ) >> 1 ;
      sliceX[1].sliceHeight   = ( sliceA.sliceHeight   + sliceB.sliceHeight   ) >> 1 ;
    }
    else castRay( px, py, pa, x - 4, &sliceX[1] );
    
    sliceX[0].textureId     =   sliceA.textureId;
    sliceX[0].textureOffset = ( sliceA.textureOffset + sliceX[1].textureOffset ) >> 1 ;
    sliceX[0].sliceHeight   = ( sliceA.sliceHeight   + sliceX[1].sliceHeight   ) >> 1 ;
    
    sliceX[2].textureId     =   sliceX[1].textureId;
    sliceX[2].textureOffset = ( sliceX[1].textureOffset + sliceB.textureOffset ) >> 1 ;
    sliceX[2].sliceHeight   = ( sliceX[1].sliceHeight   + sliceB.sliceHeight   ) >> 1 ;
    
    drawSlice( x - 3, &sliceX[0] );
    drawSlice( x - 2, &sliceX[1] );
    drawSlice( x - 1, &sliceX[2] );
    drawSlice( x,     &sliceB    );
    
    sliceA = sliceB;
  }
}


void setCameraPosition(uint16_t posX, uint16_t posY, uint16_t angle)
{
  px = (float)posX;
  py = (float)posY;
  pa = (float)angle;
}

void applyMove(float dx, float dy)
{
  px += dx;
  py += dy;
  
  /*
  // Collision detection.  Still glitchy.
  uint16_t testA = (uint16_t)( ( px - HIT_WIDTH ) / BLOCK_SIZE_F );
  uint16_t testB = (uint16_t)( ( py - HIT_WIDTH ) / BLOCK_SIZE_F );
  uint16_t testC = (uint16_t)( ( py + HIT_WIDTH ) / BLOCK_SIZE_F );
  if( pgm_read_byte( &level[ testA + MAP_WIDTH * testB ] ) || pgm_read_byte( &level[ testA + MAP_WIDTH * testC ] ) ) {
    px = (float)( testA + 1 ) * BLOCK_SIZE_F + HIT_WIDTH;
  }
  
  testA = (uint16_t)( ( px + HIT_WIDTH ) / BLOCK_SIZE_F );
  if( pgm_read_byte( &level[ testA + MAP_WIDTH * testB ] ) || pgm_read_byte( &level[ testA + MAP_WIDTH * testC ] ) ) {
    px = (float)( testA ) * BLOCK_SIZE_F - HIT_WIDTH;
  }
  */
  
  /*
  testA = (uint16_t)( ( py - HIT_WIDTH ) / BLOCK_SIZE_F );
  testB = (uint16_t)( ( px - HIT_WIDTH ) / BLOCK_SIZE_F );
  testC = (uint16_t)( ( px + HIT_WIDTH ) / BLOCK_SIZE_F );
  if( pgm_read_byte( &level[ testB + MAP_WIDTH * testA ] ) || pgm_read_byte( &level[ testC + MAP_WIDTH * testA ] ) ) {
    py = (float)( testA + 1 ) * BLOCK_SIZE_F + HIT_WIDTH;
  }
  
  testA = (uint16_t)( ( py + HIT_WIDTH ) / BLOCK_SIZE_F );
  if( pgm_read_byte( &level[ testB + MAP_WIDTH * testA ] ) || pgm_read_byte( &level[ testC + MAP_WIDTH * testA ] ) ) {
    py = (float)( testA ) * BLOCK_SIZE_F - HIT_WIDTH;
  }
*/
}

void moveCamera(uint8_t direction)
{
  if((direction & MOVE_LEFT) == MOVE_LEFT) {
    applyMove(5.0f*cos( pa - PI_1_2_NUM ), 5.0f*sin( pa - PI_1_2_NUM ));
  }
  
  if((direction & MOVE_RIGHT) == MOVE_RIGHT) {
    applyMove(-5.0f*cos( pa - PI_1_2_NUM ), -5.0f*sin( pa - PI_1_2_NUM ));
  }
  
  if((direction & MOVE_UP) == MOVE_UP) {
    applyMove(5.0f*cos( pa ), 5.0f*sin( pa ));
  }
  
  if((direction & MOVE_DOWN) == MOVE_DOWN) {
    applyMove(-5.0f*cos( pa ), -5.0f*sin( pa ));
  }
  
  if((direction & MOVE_CLOCKWISE_R) == MOVE_CLOCKWISE_R) {
    pa -= PI_NUM / 25.0f;
  }
  
  if((direction &  MOVE_CLOCKWISE_L) == MOVE_CLOCKWISE_L) {
    pa += PI_NUM / 25.0f;
  }
}
