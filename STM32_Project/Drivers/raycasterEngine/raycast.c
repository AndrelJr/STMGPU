/**
* LCDWolf3D
* jaburns
*/

#include <stdbool.h>
#include <math.h>
#include "trigonometry.h"

#include <stm32f10x.h>
#include <gfx.h>
#if USE_FSMC
 #include <fsmcdrv.h>
#else
 #include <spi.h>
#endif
//#include <memHelper.h>

#include "raycast.h"

// ---------------------------------- //
float px =  70.0f;
float py = 170.0f;
float pa = -PI_1_2_NUM;
// ---------------------------------- //

uint16_t sliceDMABuf[LCD_HEIGHT];

// step for render quality mode
// show how much vertical lines to skip
uint8_t rndrQAModeStep = RENDER_STEP_SIZE;

uint16_t *pCurrenPal;
uint8_t *pLevel;


// in texture mode == 1 drawed textures 16x16px
// in texture mode == 2 drawed textures 32x32px
//uint8_t textureMode = 1;
//uint8_t mapTextureId[MAP_TEXTURES_NUM_MAX] = {0};

// ---------------------------------- //


// -------------------------------------------------------------------- //
const uint8_t tex_wood[] = {
  0x1e, 0x2e, 0x1e, 0x1e, 0x1e, 0x2e, 0x2e, 0x1e, 0x1e, 0x2e, 0x1e, 0x1e,
  0x1e, 0x1e, 0x2e, 0x08, 0x1e, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
  0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x1e, 0x1e, 0x1e, 0x1e,
  0x2e, 0x2e, 0x08, 0x08, 0x2e, 0x1e, 0x1e, 0x1e, 0x1e, 0x2e, 0x2e, 0x1e,
  0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
  0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
  0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x1e, 0x1e, 0x1e, 0x1e,
  0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
  0x1e, 0x1e, 0x08, 0x08, 0x2e, 0x1e, 0x08, 0x08, 0x2e, 0x1e, 0x1e, 0x08,
  0x08, 0x08, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
  0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x2e,
  0x08, 0x2e, 0x1e, 0x1e, 0x2e, 0x08, 0x2e, 0x1e, 0x1e, 0x08, 0x08, 0x2e,
  0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
  0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
  0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x2e, 0x08, 0x1e, 0x1e, 0x1e, 0x1e,
  0x1e, 0x1e, 0x2e, 0x08, 0x2e, 0x1e, 0x1e, 0x1e, 0x1e, 0x08, 0x08, 0x1e,
  0x1e, 0x1e, 0x1e, 0x08, 0x08, 0x08, 0x2e, 0x1e, 0x1e, 0x1e, 0x08, 0x08,
  0x1e, 0x1e, 0x1e, 0x2e, 0x1e, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
  0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x1e, 0x1e, 0x1e, 0x1e,
  0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
  0x1e, 0x08, 0x2e, 0x1e, 0x08, 0x08, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
  0x08, 0x08, 0x1e, 0x1e
};


const uint8_t tex_bricks[] = {
  0x2e, 0x2e, 0x2e, 0x16, 0x07, 0x2e, 0x2e, 0x2e, 0x06, 0x07, 0x2e, 0x2e,
  0x2e, 0x06, 0x06, 0x08, 0x2e, 0x08, 0x07, 0x16, 0x06, 0x2e, 0x06, 0x06,
  0x06, 0x07, 0x2e, 0x06, 0x06, 0x06, 0x07, 0x08, 0x2e, 0x06, 0x07, 0x3e,
  0x2e, 0x3e, 0x07, 0x06, 0x06, 0x07, 0x1e, 0x06, 0x06, 0x16, 0x07, 0x08,
  0x2e, 0x07, 0x07, 0x06, 0x07, 0x2e, 0x07, 0x08, 0x16, 0x06, 0x2e, 0x06,
  0x06, 0x16, 0x06, 0x08, 0x2e, 0x07, 0x07, 0x06, 0x07, 0x1e, 0x07, 0x06,
  0x16, 0x07, 0x2e, 0x06, 0x07, 0x2e, 0x2e, 0x1e, 0x2e, 0x07, 0x08, 0x06,
  0x07, 0x2e, 0x06, 0x07, 0x06, 0x16, 0x2e, 0x07, 0x07, 0x06, 0x07, 0x08,
  0x2e, 0x3e, 0x2e, 0x06, 0x06, 0x1e, 0x07, 0x07, 0x06, 0x08, 0x2e, 0x07,
  0x07, 0x06, 0x07, 0x08, 0x2e, 0x07, 0x07, 0x06, 0x07, 0x2e, 0x07, 0x07,
  0x06, 0x07, 0x2e, 0x16, 0x06, 0x06, 0x07, 0x08, 0x2e, 0x06, 0x07, 0x06,
  0x07, 0x2e, 0x16, 0x06, 0x06, 0x07, 0x2e, 0x08, 0x08, 0x06, 0x07, 0x08,
  0x2e, 0x06, 0x07, 0x06, 0x06, 0x2e, 0x08, 0x08, 0x06, 0x07, 0x1e, 0x07,
  0x07, 0x16, 0x06, 0x08, 0x2e, 0x06, 0x07, 0x16, 0x07, 0x2e, 0x07, 0x07,
  0x06, 0x07, 0x2e, 0x07, 0x08, 0x16, 0x08, 0x08, 0x2e, 0x07, 0x07, 0x16,
  0x16, 0x2e, 0x07, 0x07, 0x16, 0x06, 0x1e, 0x08, 0x07, 0x3e, 0x2e, 0x2e,
  0x2e, 0x3e, 0x3e, 0x06, 0x08, 0x2e, 0x06, 0x07, 0x16, 0x07, 0x2e, 0x06,
  0x06, 0x06, 0x06, 0x08, 0x2e, 0x07, 0x07, 0x06, 0x07, 0x2e, 0x06, 0x07,
  0x2e, 0x2e, 0x2e, 0x06, 0x06, 0x06, 0x08, 0x08, 0x2e, 0x07, 0x07, 0x06,
  0x07, 0x1e, 0x07, 0x08, 0x06, 0x07, 0x2e, 0x06, 0x07, 0x06, 0x07, 0x08,
  0x2e, 0x07, 0x07, 0x16, 0x06, 0x1e, 0x07, 0x07, 0x06, 0x06, 0x2e, 0x07,
  0x07, 0x16, 0x07, 0x08
};

const uint8_t tex_bird[] = {
  0x2e, 0x09, 0x2e, 0x16, 0x07, 0x2e, 0x2e, 0x2e, 0x06, 0x07, 0x2e, 0x2e,
  0x2e, 0x06, 0x06, 0x08, 0x2e, 0x1d, 0x0d, 0x0d, 0x1d, 0x1d, 0x1d, 0x1d,
  0x1d, 0x0d, 0x1d, 0x1d, 0x1d, 0x1d, 0x08, 0x08, 0x2e, 0x1d, 0x0d, 0x1d,
  0x0d, 0x04, 0x0d, 0x04, 0x3e, 0x04, 0x1d, 0x1d, 0x1d, 0x0d, 0x3e, 0x08,
  0x2e, 0x1d, 0x1d, 0x0d, 0x14, 0x3e, 0x04, 0x04, 0x04, 0x04, 0x04, 0x1d,
  0x1d, 0x1d, 0x1d, 0x08, 0x2e, 0x1d, 0x1d, 0x04, 0x04, 0x04, 0x04, 0x04,
  0x04, 0x04, 0x04, 0x18, 0x1d, 0x1d, 0x0d, 0x1e, 0x2e, 0x1d, 0x1d, 0x3e,
  0x04, 0x14, 0x04, 0x04, 0x04, 0x04, 0x04, 0x18, 0x1d, 0x1d, 0x0d, 0x08,
  0x2e, 0x1d, 0x1d, 0x1d, 0x04, 0x04, 0x04, 0x04, 0x04, 0x0d, 0x04, 0x08,
  0x3e, 0x04, 0x1d, 0x1d, 0x2e, 0x1d, 0x1d, 0x18, 0x1d, 0x3e, 0x3e, 0x0d,
  0x04, 0x04, 0x04, 0x1d, 0x04, 0x0d, 0x1d, 0x0d, 0x2e, 0x1d, 0x1d, 0x04,
  0x04, 0x04, 0x0d, 0x14, 0x0d, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x07,
  0x2e, 0x1d, 0x1d, 0x1d, 0x1d, 0x0d, 0x04, 0x04, 0x04, 0x04, 0x04, 0x0d,
  0x04, 0x1d, 0x1d, 0x1d, 0x2e, 0x1d, 0x1d, 0x1d, 0x04, 0x04, 0x04, 0x04,
  0x04, 0x3e, 0x04, 0x08, 0x0d, 0x3e, 0x1d, 0x1d, 0x2e, 0x1d, 0x1d, 0x04,
  0x2e, 0x04, 0x14, 0x04, 0x04, 0x04, 0x04, 0x18, 0x1d, 0x1d, 0x07, 0x1e,
  0x2e, 0x1d, 0x1d, 0x04, 0x04, 0x2e, 0x04, 0x04, 0x0d, 0x04, 0x04, 0x18,
  0x0d, 0x1d, 0x0d, 0x08, 0x2e, 0x1d, 0x1d, 0x0d, 0x04, 0x2e, 0x04, 0x04,
  0x04, 0x04, 0x04, 0x1d, 0x1d, 0x1d, 0x1d, 0x08, 0x2e, 0x1d, 0x0d, 0x0d,
  0x1d, 0x1d, 0x0d, 0x04, 0x0d, 0x1d, 0x1d, 0x1d, 0x1d, 0x0d, 0x3e, 0x08,
  0x2e, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d,
  0x1d, 0x1d, 0x08, 0x08
};

const uint8_t tex_bricks2[] = {
  0x2e, 0x1d, 0x0d, 0x2e, 0x0d, 0x0d, 0x0d, 0x1e, 0x3e, 0x2e, 0x3e, 0x2e,
  0x2e, 0x2e, 0x3e, 0x3e, 0x2e, 0x1d, 0x0d, 0x2e, 0x0d, 0x0d, 0x0d, 0x2e,
  0x0d, 0x0d, 0x0d, 0x1d, 0x0d, 0x3e, 0x2e, 0x0d, 0x2e, 0x4e, 0x0d, 0x2e,
  0x0d, 0x0d, 0x0d, 0x2e, 0x1d, 0x1d, 0x0d, 0x1d, 0x0d, 0x3e, 0x2e, 0x1d,
  0x2e, 0x1d, 0x0d, 0x2e, 0x3e, 0x0d, 0x0d, 0x2e, 0x4e, 0x1d, 0x0d, 0x1d,
  0x0d, 0x3e, 0x2e, 0x1d, 0x2e, 0x4e, 0x4e, 0x0d, 0x4e, 0x1d, 0x0d, 0x0d,
  0x0d, 0x2e, 0x0d, 0x0d, 0x0d, 0x3e, 0x3e, 0x4e, 0x2e, 0x1e, 0x2e, 0x1e,
  0x1e, 0x1e, 0x0d, 0x0d, 0x0d, 0x0d, 0x3e, 0x1d, 0x0d, 0x3e, 0x2e, 0x3e,
  0x2e, 0x0d, 0x2e, 0x1d, 0x0d, 0x1e, 0x0d, 0x3e, 0x3e, 0x2e, 0x2e, 0x1d,
  0x0d, 0x3e, 0x4e, 0x2e, 0x2e, 0x1d, 0x2e, 0x4e, 0x1d, 0x2e, 0x1d, 0x0d,
  0x0d, 0x0d, 0x2e, 0x1d, 0x0d, 0x2e, 0x3e, 0x2e, 0x2e, 0x0d, 0x2e, 0x0d,
  0x1d, 0x0d, 0x1d, 0x0d, 0x1d, 0x0d, 0x2e, 0x1d, 0x0d, 0x2e, 0x0d, 0x1e,
  0x2e, 0x1e, 0x1e, 0x2e, 0x3e, 0x1e, 0x3d, 0x0d, 0x1d, 0x4e, 0x2e, 0x1d,
  0x1d, 0x3e, 0x0d, 0x1e, 0x2e, 0x1d, 0x0d, 0x0d, 0x0d, 0x2e, 0x2e, 0x2e,
  0x2e, 0x1e, 0x1e, 0x1e, 0x1e, 0x2e, 0x0d, 0x1e, 0x2e, 0x1d, 0x0d, 0x0d,
  0x0d, 0x2e, 0x0d, 0x0d, 0x1d, 0x0d, 0x0d, 0x0d, 0x3e, 0x2e, 0x1d, 0x1e,
  0x2e, 0x1d, 0x1d, 0x0d, 0x0d, 0x3e, 0x0d, 0x0d, 0x0d, 0x0d, 0x1d, 0x1d,
  0x3e, 0x2e, 0x1d, 0x1e, 0x2e, 0x4e, 0x1d, 0x2e, 0x3e, 0x2e, 0x2e, 0x2e,
  0x1e, 0x1e, 0x1e, 0x2e, 0x2e, 0x0d, 0x0d, 0x1e, 0x2e, 0x0d, 0x2e, 0x2e,
  0x0d, 0x0d, 0x3e, 0x2e, 0x0d, 0x1d, 0x1d, 0x0d, 0x3e, 0x4e, 0x1d, 0x1e,
  0x2e, 0x1d, 0x0d, 0x1e, 0x0d, 0x1d, 0x1d, 0x1e, 0x1d, 0x0d, 0x1d, 0x1d,
  0x1e, 0x4e, 0x1d, 0x1e
};


// all textures have size 64x64
const uint8_t *textures[] =
{
  0, // no texture
  tex_wood,
  tex_bricks,
  tex_bird,
  tex_bricks2
};

// ---------------------------------- //

// 24x24
const uint8_t level[] = {
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  1,2,2,3,2,2,3,2,2,3,2,2,4,4,4,4,4,4,4,4,4,4,4,1,
  1,2,0,0,0,0,0,0,0,0,0,2,4,0,0,0,0,0,0,0,0,0,4,1,
  1,3,0,0,0,0,0,0,0,0,0,3,4,0,0,0,0,0,0,0,0,0,4,1,
  1,2,0,0,0,3,2,2,2,0,0,2,4,0,0,4,0,4,0,4,0,0,4,1,
  1,2,0,0,0,2,2,0,0,0,0,2,4,0,0,0,0,0,0,0,0,0,4,1,
  1,3,0,0,0,3,3,0,0,0,0,3,4,0,0,4,0,0,0,4,0,0,4,1,
  1,2,2,0,2,2,2,0,0,0,0,2,4,0,0,0,0,4,4,4,0,0,4,1,
  1,0,2,3,2,0,2,2,0,2,2,2,4,4,4,4,4,0,0,0,4,4,4,1,
  1,0,0,0,0,0,0,4,0,4,4,4,4,4,4,4,0,0,0,0,0,4,4,1,
  1,0,0,0,0,0,0,4,0,0,0,0,0,0,4,0,0,0,0,0,0,0,4,1,
  1,0,0,0,0,0,0,4,0,0,0,0,0,0,4,0,0,0,3,0,0,0,4,1,
  1,0,0,0,0,0,0,4,0,4,4,4,0,0,0,0,0,0,0,0,0,0,4,1,
  1,0,0,0,0,0,0,4,3,4,4,4,4,4,4,4,0,0,0,0,0,4,4,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,4,4,4,1,
  1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,0,0,0,1,
  1,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,
  1,4,0,4,0,0,0,0,4,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,
  1,4,0,0,0,0,3,0,4,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,
  1,4,0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,
  1,4,0,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
};

// -------------------------------------------------------------------- //


void castRay(float x, float y, float angle, uint16_t slicePosX, slice_t *result)
{
  // origin coordinates
  float origX = x;
  float origY = y;
  
  // calculate FOV
  float offsetAngle = ((float)slicePosX * (PI_1_3_NUM)) / LCD_WIDTH - (PI_1_6_NUM);
  angle += offsetAngle;
  
  bool yAxisWall = false;
  
  // coordinate of the texture block we're sitting in
  float blockX = (float)((uint16_t)(x / BLOCK_SIZE));
  float blockY = (float)((uint16_t)(y / BLOCK_SIZE));
  
  float cosine = cos(angle);
  float sine   = sin(angle);
  
  // check for minimum and maximum; we're not need so much precision
  if((sine   <  MIN_SINE_VAL) && (sine   >= 0.0f)) sine   =  MIN_SINE_VAL;
  if((sine   > -MIN_SINE_VAL) && (sine   <  0.0f)) sine   = -MIN_SINE_VAL;
  if((cosine <  MIN_SINE_VAL) && (cosine >= 0.0f)) cosine =  MIN_SINE_VAL;
  if((cosine > -MIN_SINE_VAL) && (cosine <  0.0f)) cosine = -MIN_SINE_VAL;
  
  float oneOverCosine = 1.0f / cosine;
  float oneOverSine   = 1.0f / sine;
  
  float xNext_x, xNext_y, xNext_l;
  float yNext_x, yNext_y, yNext_l;
  
  float stepX, stepY;
  stepX = cosine > 0 ? 1.0f : -1.0f;
  stepY = sine > 0 ? 1.0f : -1.0f;
  
  //perform DDA
  do {
    xNext_x = blockX * BLOCK_SIZE_F;
    if( cosine > 0 ) xNext_x += BLOCK_SIZE_F;
    xNext_x -= x;
    xNext_l = xNext_x * oneOverCosine;
    
    yNext_y = blockY * BLOCK_SIZE_F;
    if( sine > 0 ) yNext_y += BLOCK_SIZE_F;
    yNext_y -= y;
    yNext_l = yNext_y * oneOverSine;
    
    if( xNext_l < yNext_l )
    {
      yAxisWall = true;
      xNext_y = xNext_l * sine;
      blockX += stepX;
      x += xNext_x;
      y += xNext_y;
    }
    else
    {
      yAxisWall = false;
      yNext_x = yNext_l * cosine;
      blockY += stepY;
      x += yNext_x;
      y += yNext_y;
    }
    
    result->textureId =  level[ (uint16_t)(blockX + MAP_WIDTH * blockY)];
  } while(result->textureId == 0);
  
  result->targetBlockX = (uint16_t)blockX;
  result->targetBlockY = (uint16_t)blockY;
  
  if(yAxisWall) {
    result->textureOffset = (uint16_t)( (uint16_t)(y * TEXTURE_SIZE_OFF) % TEXTURE_SIZE);
  } else {
    result->textureOffset = (uint16_t)( (uint16_t)(x * TEXTURE_SIZE_OFF) % TEXTURE_SIZE);
  }
  
  // calculate wall projection plane height
  float dx = x - origX;
  float dy = y - origY;
  float dd = sqrt(dx*dx + dy*dy) * cos(offsetAngle);
  
  result->sliceHeight = (uint16_t)(VISPLANEDIST_TIMES_WALLHEIGHT/dd);
}

void drawSlice( uint16_t screenX, slice_t *slice )
{
  uint16_t offsetY   = ( slice->sliceHeight >  LCD_HEIGHT) ? (0) : ((LCD_HEIGHT/2) - (slice->sliceHeight >> 1));
  uint16_t overflowY = ( slice->sliceHeight <= LCD_HEIGHT) ? (0) : ((slice->sliceHeight - LCD_HEIGHT) >> 1);
  
  uint16_t sliceYcount =0;
  uint8_t colorId =0;
  uint16_t textureYOffset =0;
  
  for(; sliceYcount < slice->sliceHeight && sliceYcount < LCD_HEIGHT; sliceYcount++) {
    
    textureYOffset = ((sliceYcount + overflowY) * TEXTURE_SIZE) / slice->sliceHeight;
    
    colorId = textures[slice->textureId][slice->textureOffset*TEXTURE_SIZE + textureYOffset];
    
    sliceDMABuf[sliceYcount] = pCurrenPal[colorId];
  }
  
  setVAddrWindow(OFFSET_X+screenX, OFFSET_Y+offsetY, OFFSET_Y+offsetY+sliceYcount);
  sendData16_Fast_DMA1_SPI1(sliceDMABuf, sliceYcount);
}

bool shouldInterpolate(slice_t *sliceA, slice_t *sliceB)
{
  if(sliceA->textureId == sliceB->textureId) {
    uint16_t xDiff = UNSIGNED_DIFF(sliceA->targetBlockX, sliceB->targetBlockX);
    uint16_t yDiff = UNSIGNED_DIFF(sliceA->targetBlockY, sliceB->targetBlockY);
    
    if(xDiff == 0 && yDiff <= 1) return true;
    if(xDiff <= 1 && yDiff == 0) return true;
  }
 
  return false;
}

void renderWalls(void)
{
  // clear previous render frame
  fillRect(OFFSET_X+0, OFFSET_Y+0, LCD_WIDTH, LCD_HEIGHT, COLOR_BLACK);
  
  slice_t sliceA, sliceB;
  slice_t sliceX[3];
  
  castRay(px, py, pa, 0, &sliceA);
  
  for(uint16_t x = rndrQAModeStep; x < LCD_WIDTH; x += rndrQAModeStep) {
    castRay(px, py, pa, x, &sliceB);
    
    if(shouldInterpolate(&sliceA , &sliceB)) {
      sliceX[1].textureId     =  sliceA.textureId;
      sliceX[1].textureOffset = (sliceA.textureOffset + sliceB.textureOffset) >> 1;
      sliceX[1].sliceHeight   = (sliceA.sliceHeight   + sliceB.sliceHeight  ) >> 1;
    } else {
      castRay(px, py, pa, x - 4, &sliceX[1]);
    }
    
    sliceX[0].textureId     =  sliceA.textureId;
    sliceX[0].textureOffset = (sliceA.textureOffset + sliceX[1].textureOffset) >> 1;
    sliceX[0].sliceHeight   = (sliceA.sliceHeight   + sliceX[1].sliceHeight  ) >> 1;
    
    sliceX[2].textureId     =  sliceX[1].textureId;
    sliceX[2].textureOffset = (sliceX[1].textureOffset + sliceB.textureOffset) >> 1;
    sliceX[2].sliceHeight   = (sliceX[1].sliceHeight   + sliceB.sliceHeight  ) >> 1;
    
    drawSlice(x-3, &sliceX[0]);
    drawSlice(x-2, &sliceX[1]);
    drawSlice(x-1, &sliceX[2]);
    drawSlice(x,   &sliceB   );
    
    sliceA = sliceB;
  }
}


void setCameraPosition(uint16_t posX, uint16_t posY, uint16_t angle)
{
  px = (float)posX;
  py = (float)posY;
  pa = (float)angle;
}

void applyMove(float dx, float dy)
{
  px += dx;
  py += dy;
  
  /*
  // Collision detection.  Still glitchy.
  uint16_t testA = (uint16_t)( ( px - HIT_WIDTH ) / BLOCK_SIZE_F );
  uint16_t testB = (uint16_t)( ( py - HIT_WIDTH ) / BLOCK_SIZE_F );
  uint16_t testC = (uint16_t)( ( py + HIT_WIDTH ) / BLOCK_SIZE_F );
  if( pgm_read_byte( &level[ testA + MAP_WIDTH * testB ] ) || pgm_read_byte( &level[ testA + MAP_WIDTH * testC ] ) ) {
    px = (float)( testA + 1 ) * BLOCK_SIZE_F + HIT_WIDTH;
  }
  
  testA = (uint16_t)( ( px + HIT_WIDTH ) / BLOCK_SIZE_F );
  if( pgm_read_byte( &level[ testA + MAP_WIDTH * testB ] ) || pgm_read_byte( &level[ testA + MAP_WIDTH * testC ] ) ) {
    px = (float)( testA ) * BLOCK_SIZE_F - HIT_WIDTH;
  }
  */
  
  /*
  testA = (uint16_t)( ( py - HIT_WIDTH ) / BLOCK_SIZE_F );
  testB = (uint16_t)( ( px - HIT_WIDTH ) / BLOCK_SIZE_F );
  testC = (uint16_t)( ( px + HIT_WIDTH ) / BLOCK_SIZE_F );
  if( pgm_read_byte( &level[ testB + MAP_WIDTH * testA ] ) || pgm_read_byte( &level[ testC + MAP_WIDTH * testA ] ) ) {
    py = (float)( testA + 1 ) * BLOCK_SIZE_F + HIT_WIDTH;
  }
  
  testA = (uint16_t)( ( py + HIT_WIDTH ) / BLOCK_SIZE_F );
  if( pgm_read_byte( &level[ testB + MAP_WIDTH * testA ] ) || pgm_read_byte( &level[ testC + MAP_WIDTH * testA ] ) ) {
    py = (float)( testA ) * BLOCK_SIZE_F - HIT_WIDTH;
  }
*/
}

void moveCamera(uint8_t direction)
{
  if((direction & MOVE_LEFT) == MOVE_LEFT) {
    applyMove(MOVE_SPEED*cos(pa - PI_1_2_NUM), MOVE_SPEED*sin(pa - PI_1_2_NUM));
  }
  
  if((direction & MOVE_RIGHT) == MOVE_RIGHT) {
    applyMove(-MOVE_SPEED*cos(pa - PI_1_2_NUM), -MOVE_SPEED*sin(pa - PI_1_2_NUM));
  }
  
  if((direction & MOVE_UP) == MOVE_UP) {
    applyMove(MOVE_SPEED*cos(pa), MOVE_SPEED*sin(pa));
  }
  
  if((direction & MOVE_DOWN) == MOVE_DOWN) {
    applyMove(-MOVE_SPEED*cos(pa), -MOVE_SPEED*sin(pa));
  }
  
  if((direction & MOVE_CLOCKWISE_R) == MOVE_CLOCKWISE_R) {
    pa -= ROT_ANGLE_STEP;
  }
  
  if((direction &  MOVE_CLOCKWISE_L) == MOVE_CLOCKWISE_L) {
    pa += ROT_ANGLE_STEP;
  }
}

// this is need because this driver is separatted
// from other sources
void setRayCastPalette(uint16_t *pPal)
{
  // set pointer to color palette
  pCurrenPal = pPal;
}

void setLevelMap(uint8_t *pLevelMap)
{
  pLevel = pLevelMap;
}

void serRenderQuality(uint8_t quality)
{
  if((quality >= RENDER_QA_MIN) || (quality <= RENDER_QA_MAX)) {
    rndrQAModeStep = quality;
  }
}
